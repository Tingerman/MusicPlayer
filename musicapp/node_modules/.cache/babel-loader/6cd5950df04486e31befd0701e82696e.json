{"ast":null,"code":"import { now, nextTick } from '../../../utils/utils';\nexport default function onTouchEnd(event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params,\n      touches = swiper.touches,\n      rtl = swiper.rtlTranslate,\n      $wrapperEl = swiper.$wrapperEl,\n      slidesGrid = swiper.slidesGrid,\n      snapGrid = swiper.snapGrid;\n  var e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  var touchEndTime = now();\n  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = now();\n  nextTick(function () {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  var currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        var lastMoveEvent = data.velocities.pop();\n        var velocityEvent = data.velocities.pop();\n        var distance = lastMoveEvent.position - velocityEvent.position;\n        var time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n      data.velocities.length = 0;\n      var momentumDuration = 1000 * params.freeModeMomentumRatio;\n      var momentumDistance = swiper.velocity * momentumDuration;\n      var newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      var doBounce = false;\n      var afterBouncePosition;\n      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      var needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        var nextSlide;\n\n        for (var j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', function () {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(function () {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(function () {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(function () {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(function () {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    return;\n  } // Find current slide\n\n\n  var stopIndex = 0;\n  var groupSize = swiper.slidesSizesGrid[0];\n\n  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (typeof slidesGrid[i + _increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + _increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  } // Find current slide size\n\n\n  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}","map":{"version":3,"names":["now","nextTick","onTouchEnd","event","swiper","data","touchEventsData","params","touches","rtl","rtlTranslate","$wrapperEl","slidesGrid","snapGrid","e","originalEvent","allowTouchCallbacks","emit","isTouched","isMoved","grabCursor","setGrabCursor","startMoving","allowSlideNext","allowSlidePrev","touchEndTime","timeDiff","touchStartTime","allowClick","updateClickedSlide","lastClickTime","destroyed","swipeDirection","diff","currentTranslate","startTranslate","currentPos","followFinger","translate","cssMode","freeMode","minTranslate","slideTo","activeIndex","maxTranslate","slides","length","freeModeMomentum","velocities","lastMoveEvent","pop","velocityEvent","distance","position","time","velocity","Math","abs","freeModeMinimumVelocity","freeModeMomentumVelocityRatio","momentumDuration","freeModeMomentumRatio","momentumDistance","newPosition","doBounce","afterBouncePosition","bounceAmount","freeModeMomentumBounceRatio","needsLoopFix","freeModeMomentumBounce","allowMomentumBounce","loop","centeredSlides","freeModeSticky","nextSlide","j","once","loopFix","moveDistance","currentSlideSize","slidesSizesGrid","speed","slideToClosest","updateProgress","setTransition","setTranslate","transitionStart","animating","transitionEnd","setTimeout","updateActiveIndex","updateSlidesClasses","longSwipesMs","stopIndex","groupSize","i","slidesPerGroupSkip","slidesPerGroup","_increment","ratio","increment","longSwipes","longSwipesRatio","shortSwipes","isNavButtonTarget","navigation","target","nextEl","prevEl"],"sources":["/Users/wangmanting/Desktop/云e办/音乐播放器vue项目/musicapp/node_modules/swiper/esm/components/core/events/onTouchEnd.js"],"sourcesContent":["import { now, nextTick } from '../../../utils/utils';\nexport default function onTouchEnd(event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params,\n      touches = swiper.touches,\n      rtl = swiper.rtlTranslate,\n      $wrapperEl = swiper.$wrapperEl,\n      slidesGrid = swiper.slidesGrid,\n      snapGrid = swiper.snapGrid;\n  var e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  var touchEndTime = now();\n  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = now();\n  nextTick(function () {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  var currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        var lastMoveEvent = data.velocities.pop();\n        var velocityEvent = data.velocities.pop();\n        var distance = lastMoveEvent.position - velocityEvent.position;\n        var time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n      data.velocities.length = 0;\n      var momentumDuration = 1000 * params.freeModeMomentumRatio;\n      var momentumDistance = swiper.velocity * momentumDuration;\n      var newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      var doBounce = false;\n      var afterBouncePosition;\n      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      var needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        var nextSlide;\n\n        for (var j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', function () {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(function () {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(function () {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(function () {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(function () {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    return;\n  } // Find current slide\n\n\n  var stopIndex = 0;\n  var groupSize = swiper.slidesSizesGrid[0];\n\n  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (typeof slidesGrid[i + _increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + _increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  } // Find current slide size\n\n\n  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}