{"ast":null,"code":"import { getWindow, getDocument } from 'ssr-window';\nimport $ from '../../utils/dom';\nimport { now, nextTick, bindModuleMethods } from '../../utils/utils';\n\nfunction isEventSupported() {\n  var document = getDocument();\n  var eventName = 'onwheel';\n  var isSupported = (eventName in document);\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nvar Mousewheel = {\n  lastScrollTime: now(),\n  lastEventBeforeSnap: undefined,\n  recentWheelEvents: [],\n  event: function event() {\n    var window = getWindow();\n    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  },\n  normalize: function normalize(e) {\n    // Reasonable defaults\n    var PIXEL_STEP = 10;\n    var LINE_HEIGHT = 40;\n    var PAGE_HEIGHT = 800;\n    var sX = 0;\n    var sY = 0; // spinX, spinY\n\n    var pX = 0;\n    var pY = 0; // pixelX, pixelY\n    // Legacy\n\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    } // side scrolling on FF with DOMMouseScroll\n\n\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    } // Fall-back if spin cannot be determined\n\n\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  },\n  handleMouseEnter: function handleMouseEnter() {\n    var swiper = this;\n    swiper.mouseEntered = true;\n  },\n  handleMouseLeave: function handleMouseLeave() {\n    var swiper = this;\n    swiper.mouseEntered = false;\n  },\n  handle: function handle(event) {\n    var e = event;\n    var swiper = this;\n    var params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n    var delta = 0;\n    var rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    var data = Mousewheel.normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    if (!swiper.params.freeMode) {\n      // Register the new event in a variable which stores the relevant data\n      var newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      }; // Keep the most recent events\n\n      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          swiper.mousewheel.animateSlider(newEvent);\n        }\n      } else {\n        swiper.mousewheel.animateSlider(newEvent);\n      } // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n\n\n      if (swiper.mousewheel.releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      var _newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;\n      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;\n\n      if (!ignoreWheelEvents) {\n        swiper.mousewheel.lastEventBeforeSnap = undefined;\n\n        if (swiper.params.loop) {\n          swiper.loopFix();\n        }\n\n        var position = swiper.getTranslate() + delta * params.sensitivity;\n        var wasBeginning = swiper.isBeginning;\n        var wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n\n        if (swiper.params.freeModeSticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(swiper.mousewheel.timeout);\n          swiper.mousewheel.timeout = undefined;\n          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n          if (_recentWheelEvents.length >= 15) {\n            _recentWheelEvents.shift(); // only store the last N events\n\n          }\n\n          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;\n\n          var firstEvent = _recentWheelEvents[0];\n\n          _recentWheelEvents.push(_newEvent);\n\n          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            _recentWheelEvents.splice(0);\n          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            var snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n            _recentWheelEvents.splice(0);\n\n            swiper.mousewheel.timeout = nextTick(function () {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!swiper.mousewheel.timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            swiper.mousewheel.timeout = nextTick(function () {\n              var snapToThreshold = 0.5;\n              swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n              _recentWheelEvents.splice(0);\n\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        } // Emit event\n\n\n        if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay\n\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  },\n  animateSlider: function animateSlider(newEvent) {\n    var swiper = this;\n    var window = getWindow();\n\n    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (this.params.mousewheel.thresholdTime && now() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    } // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n\n\n    if (newEvent.delta >= 6 && now() - swiper.mousewheel.lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    } // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n\n\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        swiper.emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      swiper.emit('scroll', newEvent.raw);\n    } // If you got here is because an animation has been triggered so store the current time\n\n\n    swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n    return false;\n  },\n  releaseScroll: function releaseScroll(newEvent) {\n    var swiper = this;\n    var params = swiper.params.mousewheel;\n\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n\n    return false;\n  },\n  enable: function enable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\n    target.on(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable: function disable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (!swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.off(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n};\nexport default {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    bindModuleMethods(swiper, {\n      mousewheel: {\n        enabled: false,\n        lastScrollTime: now(),\n        lastEventBeforeSnap: undefined,\n        recentWheelEvents: [],\n        enable: Mousewheel.enable,\n        disable: Mousewheel.disable,\n        handle: Mousewheel.handle,\n        handleMouseEnter: Mousewheel.handleMouseEnter,\n        handleMouseLeave: Mousewheel.handleMouseLeave,\n        animateSlider: Mousewheel.animateSlider,\n        releaseScroll: Mousewheel.releaseScroll\n      }\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        swiper.mousewheel.disable();\n      }\n\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\n    },\n    destroy: function destroy(swiper) {\n      if (swiper.params.cssMode) {\n        swiper.mousewheel.enable();\n      }\n\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\n    }\n  }\n};","map":{"version":3,"names":["getWindow","getDocument","$","now","nextTick","bindModuleMethods","isEventSupported","document","eventName","isSupported","element","createElement","setAttribute","implementation","hasFeature","Mousewheel","lastScrollTime","lastEventBeforeSnap","undefined","recentWheelEvents","event","window","navigator","userAgent","indexOf","normalize","e","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","shiftKey","deltaMode","spinX","spinY","pixelX","pixelY","handleMouseEnter","swiper","mouseEntered","handleMouseLeave","handle","params","mousewheel","cssMode","preventDefault","target","$el","eventsTarget","contains","releaseOnEdges","originalEvent","delta","rtlFactor","rtlTranslate","data","forceToAxis","isHorizontal","Math","abs","invert","freeMode","newEvent","time","direction","sign","raw","length","shift","prevEvent","push","animateSlider","releaseScroll","_newEvent","ignoreWheelEvents","loop","loopFix","position","getTranslate","sensitivity","wasBeginning","isBeginning","wasEnd","isEnd","minTranslate","maxTranslate","setTransition","setTranslate","updateProgress","updateActiveIndex","updateSlidesClasses","freeModeSticky","clearTimeout","timeout","_recentWheelEvents","_prevEvent","firstEvent","splice","snapToThreshold","slideToClosest","speed","emit","autoplay","autoplayDisableOnInteraction","stop","returnValue","thresholdDelta","thresholdTime","animating","slideNext","slidePrev","Date","getTime","enable","wrapperEl","removeEventListener","enabled","on","disable","addEventListener","off","name","create","init","destroy"],"sources":["/Users/wangmanting/Desktop/云e办/音乐播放器vue项目/musicapp/node_modules/swiper/esm/components/mousewheel/mousewheel.js"],"sourcesContent":["import { getWindow, getDocument } from 'ssr-window';\nimport $ from '../../utils/dom';\nimport { now, nextTick, bindModuleMethods } from '../../utils/utils';\n\nfunction isEventSupported() {\n  var document = getDocument();\n  var eventName = 'onwheel';\n  var isSupported = (eventName in document);\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nvar Mousewheel = {\n  lastScrollTime: now(),\n  lastEventBeforeSnap: undefined,\n  recentWheelEvents: [],\n  event: function event() {\n    var window = getWindow();\n    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  },\n  normalize: function normalize(e) {\n    // Reasonable defaults\n    var PIXEL_STEP = 10;\n    var LINE_HEIGHT = 40;\n    var PAGE_HEIGHT = 800;\n    var sX = 0;\n    var sY = 0; // spinX, spinY\n\n    var pX = 0;\n    var pY = 0; // pixelX, pixelY\n    // Legacy\n\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    } // side scrolling on FF with DOMMouseScroll\n\n\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    } // Fall-back if spin cannot be determined\n\n\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  },\n  handleMouseEnter: function handleMouseEnter() {\n    var swiper = this;\n    swiper.mouseEntered = true;\n  },\n  handleMouseLeave: function handleMouseLeave() {\n    var swiper = this;\n    swiper.mouseEntered = false;\n  },\n  handle: function handle(event) {\n    var e = event;\n    var swiper = this;\n    var params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n    var delta = 0;\n    var rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    var data = Mousewheel.normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    if (!swiper.params.freeMode) {\n      // Register the new event in a variable which stores the relevant data\n      var newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      }; // Keep the most recent events\n\n      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          swiper.mousewheel.animateSlider(newEvent);\n        }\n      } else {\n        swiper.mousewheel.animateSlider(newEvent);\n      } // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n\n\n      if (swiper.mousewheel.releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      var _newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;\n      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;\n\n      if (!ignoreWheelEvents) {\n        swiper.mousewheel.lastEventBeforeSnap = undefined;\n\n        if (swiper.params.loop) {\n          swiper.loopFix();\n        }\n\n        var position = swiper.getTranslate() + delta * params.sensitivity;\n        var wasBeginning = swiper.isBeginning;\n        var wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n\n        if (swiper.params.freeModeSticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(swiper.mousewheel.timeout);\n          swiper.mousewheel.timeout = undefined;\n          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n          if (_recentWheelEvents.length >= 15) {\n            _recentWheelEvents.shift(); // only store the last N events\n\n          }\n\n          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;\n\n          var firstEvent = _recentWheelEvents[0];\n\n          _recentWheelEvents.push(_newEvent);\n\n          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            _recentWheelEvents.splice(0);\n          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            var snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n            _recentWheelEvents.splice(0);\n\n            swiper.mousewheel.timeout = nextTick(function () {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!swiper.mousewheel.timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            swiper.mousewheel.timeout = nextTick(function () {\n              var snapToThreshold = 0.5;\n              swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n              _recentWheelEvents.splice(0);\n\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        } // Emit event\n\n\n        if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay\n\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  },\n  animateSlider: function animateSlider(newEvent) {\n    var swiper = this;\n    var window = getWindow();\n\n    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (this.params.mousewheel.thresholdTime && now() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    } // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n\n\n    if (newEvent.delta >= 6 && now() - swiper.mousewheel.lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    } // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n\n\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        swiper.emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      swiper.emit('scroll', newEvent.raw);\n    } // If you got here is because an animation has been triggered so store the current time\n\n\n    swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n    return false;\n  },\n  releaseScroll: function releaseScroll(newEvent) {\n    var swiper = this;\n    var params = swiper.params.mousewheel;\n\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n\n    return false;\n  },\n  enable: function enable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\n    target.on(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable: function disable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (!swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.off(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n};\nexport default {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    bindModuleMethods(swiper, {\n      mousewheel: {\n        enabled: false,\n        lastScrollTime: now(),\n        lastEventBeforeSnap: undefined,\n        recentWheelEvents: [],\n        enable: Mousewheel.enable,\n        disable: Mousewheel.disable,\n        handle: Mousewheel.handle,\n        handleMouseEnter: Mousewheel.handleMouseEnter,\n        handleMouseLeave: Mousewheel.handleMouseLeave,\n        animateSlider: Mousewheel.animateSlider,\n        releaseScroll: Mousewheel.releaseScroll\n      }\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        swiper.mousewheel.disable();\n      }\n\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\n    },\n    destroy: function destroy(swiper) {\n      if (swiper.params.cssMode) {\n        swiper.mousewheel.enable();\n      }\n\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\n    }\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}